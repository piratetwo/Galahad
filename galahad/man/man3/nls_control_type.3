.TH "nls_control_type" 3 "Mon Sep 27 2021" "C interfaces to GALAHAD NLS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
nls_control_type
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <nls\&.h>\fP
.SS "Data Fields"

.in +1c
.ti -1c
.RI "bool \fBf_indexing\fP"
.br
.RI "use C or Fortran sparse matrix indexing "
.ti -1c
.RI "int \fBerror\fP"
.br
.RI "error and warning diagnostics occur on stream error "
.ti -1c
.RI "int \fBout\fP"
.br
.RI "general output occurs on stream out "
.ti -1c
.RI "int \fBprint_level\fP"
.br
.RI "the level of output required\&. "
.ti -1c
.RI "int \fBstart_print\fP"
.br
.RI "any printing will start on this iteration "
.ti -1c
.RI "int \fBstop_print\fP"
.br
.RI "any printing will stop on this iteration "
.ti -1c
.RI "int \fBprint_gap\fP"
.br
.RI "the number of iterations between printing "
.ti -1c
.RI "int \fBmaxit\fP"
.br
.RI "the maximum number of iterations performed "
.ti -1c
.RI "int \fBalive_unit\fP"
.br
.RI "removal of the file alive_file from unit alive_unit terminates execution "
.ti -1c
.RI "char \fBalive_file\fP [31]"
.br
.RI "see alive_unit "
.ti -1c
.RI "int \fBjacobian_available\fP"
.br
.RI "is the Jacobian matrix of first derivatives available (>= 2), is access only via matrix-vector products (=1) or is it not available (<= 0) ? "
.ti -1c
.RI "int \fBhessian_available\fP"
.br
.RI "is the Hessian matrix of second derivatives available (>= 2), is access only via matrix-vector products (=1) or is it not available (<= 0) ? "
.ti -1c
.RI "int \fBmodel\fP"
.br
.RI "the model used\&. "
.ti -1c
.RI "int \fBnorm\fP"
.br
.RI "the regularization norm used\&. 
.br
 "
.ti -1c
.RI "int \fBnon_monotone\fP"
.br
.RI "non-monotone <= 0 monotone strategy used, anything else non-monotone strategy with this history length used "
.ti -1c
.RI "int \fBweight_update_strategy\fP"
.br
.RI "define the weight-update strategy: 1 (basic), 2 (reset to zero when very successful), 3 (imitate TR), 4 (increase lower bound), 5 (GPT) "
.ti -1c
.RI "real_wp_ \fBstop_c_absolute\fP"
.br
.RI "overall convergence tolerances\&. The iteration will terminate when ||c(x)||_2 <= MAX( \&.stop_c_absolute, \&.stop_c_relative "
.ti -1c
.RI "real_wp_ \fBstop_c_relative\fP"
.br
.RI "see stop_c_absolute "
.ti -1c
.RI "real_wp_ \fBstop_g_absolute\fP"
.br
.RI "see stop_c_absolute "
.ti -1c
.RI "real_wp_ \fBstop_g_relative\fP"
.br
.RI "see stop_c_absolute "
.ti -1c
.RI "real_wp_ \fBstop_s\fP"
.br
.RI "see stop_c_absolute "
.ti -1c
.RI "real_wp_ \fBpower\fP"
.br
.RI "the regularization power (<2 => chosen according to the model) "
.ti -1c
.RI "real_wp_ \fBinitial_weight\fP"
.br
.RI "initial value for the regularization weight (-ve => 1/||g_0||)) "
.ti -1c
.RI "real_wp_ \fBminimum_weight\fP"
.br
.RI "minimum permitted regularization weight "
.ti -1c
.RI "real_wp_ \fBinitial_inner_weight\fP"
.br
.RI "initial value for the inner regularization weight for tensor GN (-ve => 0) "
.ti -1c
.RI "real_wp_ \fBeta_successful\fP"
.br
.RI "REAL ( KIND = wp ) :: initial_inner_weight = 0\&.0001_wp a potential iterate will only be accepted if the actual decrease f - f(x_new) is larger than \&.eta_successful times that predicted by a quadratic model of the decrease\&. The regularization weight will be decreaed if this relative decrease is greater than \&.eta_very_successful but smaller than \&.eta_too_successful\&. "
.ti -1c
.RI "real_wp_ \fBeta_very_successful\fP"
.br
.RI "see eta_successful "
.ti -1c
.RI "real_wp_ \fBeta_too_successful\fP"
.br
.RI "see eta_successful "
.ti -1c
.RI "real_wp_ \fBweight_decrease_min\fP"
.br
.RI "on very successful iterations, the regularization weight will be reduced by the factor \&.weight_decrease but no more than \&.weight_decrease_min while if the iteration is unsucceful, the weight will be increased by a factor \&.weight_increase but no more than \&.weight_increase_max (these are delta_1, delta_2, delta3 and delta_max in Gould, Porcelli and Toint, 2011) "
.ti -1c
.RI "real_wp_ \fBweight_decrease\fP"
.br
.RI "REAL ( KIND = wp ) :: weight_decrease = half\&. "
.ti -1c
.RI "real_wp_ \fBweight_increase\fP"
.br
.RI "REAL ( KIND = wp ) :: weight_increase = two\&. "
.ti -1c
.RI "real_wp_ \fBweight_increase_max\fP"
.br
.RI "see weight_increase "
.ti -1c
.RI "real_wp_ \fBreduce_gap\fP"
.br
.RI "expert parameters as suggested in Gould, Porcelli and Toint, 'Updating t
regularization parameter in the adaptive cubic regularization algorithm' RAL-TR-2011-007, Rutherford Appleton Laboratory, England (2011), http://epubs.stfc.ac.uk/bitstream/6181/RAL-TR-2011-007.pdf (these are denoted beta, epsilon_chi and alpha_max in the paper) "
.ti -1c
.RI "real_wp_ \fBtiny_gap\fP"
.br
.RI "see reduce_gap "
.ti -1c
.RI "real_wp_ \fBlarge_root\fP"
.br
.RI "see reduce_gap "
.ti -1c
.RI "real_wp_ \fBswitch_to_newton\fP"
.br
.RI "if the Gauss-Newto to Newton model is specified, switch to Newton as soon as the norm of the gradient g is smaller than switch_to_newton "
.ti -1c
.RI "real_wp_ \fBcpu_time_limit\fP"
.br
.RI "the maximum CPU time allowed (-ve means infinite) "
.ti -1c
.RI "real_wp_ \fBclock_time_limit\fP"
.br
.RI "the maximum elapsed clock time allowed (-ve means infinite) "
.ti -1c
.RI "bool \fBsubproblem_direct\fP"
.br
.RI "use a direct (factorization) or (preconditioned) iterative method to find the search direction "
.ti -1c
.RI "bool \fBrenormalize_weight\fP"
.br
.RI "should the weight be renormalized to account for a change in scaling? "
.ti -1c
.RI "bool \fBmagic_step\fP"
.br
.RI "allow the user to perform a 'magic' step to improve the objective "
.ti -1c
.RI "bool \fBprint_obj\fP"
.br
.RI "print values of the objective/gradient rather than ||c|| and its gradien "
.ti -1c
.RI "bool \fBspace_critical\fP"
.br
.RI "if \&.space_critical true, every effort will be made to use as little space as possible\&. This may result in longer computation time "
.ti -1c
.RI "bool \fBdeallocate_error_fatal\fP"
.br
.RI "if \&.deallocate_error_fatal is true, any array/pointer deallocation error will terminate execution\&. Otherwise, computation will continue "
.ti -1c
.RI "char \fBprefix\fP [31]"
.br
.RI "all output lines will be prefixed by \&.prefix(2:LEN(TRIM(\&.prefix))-1) where \&.prefix contains the required string enclosed in quotes, e\&.g\&. 'string' or 'string' "
.ti -1c
.RI "struct \fBnls_subproblem_control_type\fP \fBsubproblem_control\fP"
.br
.RI "control parameters for the step-finding subproblem "
.in -1c
.SH "Detailed Description"
.PP 
control derived type as a C struct 
.SH "Field Documentation"
.PP 
.SS "int model"

.PP
the model used\&. Possible values are 
.PD 0

.IP "\(bu" 2
0 dynamic (\fInot yet implemented\fP) 
.IP "\(bu" 2
1 first-order (no Hessian) 
.IP "\(bu" 2
2 barely second-order (identity Hessian) 
.IP "\(bu" 2
3 Gauss-Newton (J^T J Hessian) 
.IP "\(bu" 2
4 second-order (exact Hessian) 
.IP "\(bu" 2
5 Gauss-Newton to Newton transition 
.IP "\(bu" 2
6 tensor Gauss-Newton treated as a least-squares model 
.IP "\(bu" 2
7 tensor Gauss-Newton treated as a general model 
.IP "\(bu" 2
8 tensor Gauss-Newton transition from a least-squares to a general mode 
.PP

.SS "int norm"

.PP
the regularization norm used\&. 
.br
 The norm is defined via ||v||^2 = v^T S v, and will define the preconditioner used for iterative methods\&. Possible values for S are
.PP
.PD 0
.IP "\(bu" 2
-3 user's own regularization norm 
.IP "\(bu" 2
-2 S = limited-memory BFGS matrix (with \&.PSLS_control\&.lbfgs_vectors history) (\fInot yet implemented\fP) 
.IP "\(bu" 2
-1 identity (= Euclidan two-norm) 
.IP "\(bu" 2
0 automatic (\fInot yet implemented\fP) 
.IP "\(bu" 2
1 diagonal, S = diag( max( J^TJ Hessian, \&.PSLS_contro\&.min_diagonal ) ) 
.IP "\(bu" 2
2 diagonal, S = diag( max( Hessian, \&.PSLS_contro\&.min_diagonal ) ) 
.IP "\(bu" 2
3 banded, S = band( Hessian ) with semi-bandwidth \&.PSLS_control\&.semi_bandwidth 
.IP "\(bu" 2
4 re-ordered band, P=band(order(A)) with semi-bandwidth \&.PSLS_control\&.semi_bandwidth 
.IP "\(bu" 2
5 full factorization, S = Hessian, Schnabel-Eskow modification 
.IP "\(bu" 2
6 full factorization, S = Hessian, GMPS modification (\fInot yet implemented\fP) 
.IP "\(bu" 2
7 incomplete factorization of Hessian, Lin-More' 
.IP "\(bu" 2
8 incomplete factorization of Hessian, HSL_MI28 
.IP "\(bu" 2
9 incomplete factorization of Hessian, Munskgaard (\fInot yet implemented\fP) 
.IP "\(bu" 2
10 expanding band of Hessian (\fInot yet implemented\fP) 
.PP

.SS "int print_level"

.PP
the level of output required\&. 
.PD 0

.IP "\(bu" 2
<= 0 gives no output, 
.IP "\(bu" 2
= 1 gives a one-line summary for every iteration, 
.IP "\(bu" 2
= 2 gives a summary of the inner iteration for each iteration, 
.IP "\(bu" 2
>= 3 gives increasingly verbose (debugging) output 
.PP

.SS "real_wp_ stop_c_absolute"

.PP
overall convergence tolerances\&. The iteration will terminate when ||c(x)||_2 <= MAX( \&.stop_c_absolute, \&.stop_c_relative 
.IP "\(bu" 2
||c(x_{\\mbox{initial}})||_2 or when the norm of the gradient, g = J^T(x) c(x) / ||c(x)||_2, of ||c(x)||_2 satisfies ||g||_2 <= MAX( \&.stop_g_absolute, \&.stop_g_relative
.IP "\(bu" 2
||g_{\\mbox{initial}}||_2, or if the step is less than \&.stop_s 
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for C interfaces to GALAHAD NLS from the source code\&.
