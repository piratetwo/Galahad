/* -*- buffer-read-only: t -*- vi: set ro:
 *
 * DO NOT EDIT THIS FILE   (C_Worhp_Data.h)
 *
 * It has been AutoGen-ed
 * From the definitions    auto/NLP.def
 * and the template file   C_Worhp_Data.tpl */

#include <stdlib.h> /* For size_t */

#ifndef HEADER_C_WORHP_DATA_H_GUARD
#define HEADER_C_WORHP_DATA_H_GUARD 1

#ifdef __cplusplus
extern "C" {
#endif

#include "C_std.h"
#include "C_cs.h"
#include "C_timer.h"
#include "C_qp_data.h"
#include "C_filter_data.h"
#include "C_worhp_queue.h"

#define PATCH_STRING_LENGTH 8

extern const int worhp_major;
extern const int worhp_minor;
extern const char worhp_patch[PATCH_STRING_LENGTH];

extern const int nMemberOptVar;
extern const int nMemberWorkspace;
extern const int nMemberParams;
extern const int nMemberControl;

/* Used in conditional for allocating the opt->G members. */
extern const int minM;

enum {
 /* mode: classic interior-point method */
  IP_Mode_Ip = 1,
 /* mode: penalty-interior-point method */
  IP_Mode_Pipa = 2,
 /* mode: multiplier estimation */
  IP_Mode_Est = 3,
 /* mode: second order correction refinement. */
  IP_Mode_Ref = 4,
 /* stage status: everything fine, continue. */
  IP_Status_OK = 10,
 /* stage status: nothing fine, maybe stop. */
  IP_Status_NotOK = 20,
 /* stage status: otherwise. */
  IP_Status_Else = 30,
 /* stage status: optimal solution found. */
  IP_Status_Optimal = 40,
 /* stage status: optimal solution found of modified problem. */
  IP_Status_ModOptimal = 50,
 /* stage status: optimal solution found by lowpass filter. */
  IP_Status_LowpassOptimal = 60,
 /* stage status: optimal solution found of barrier problem. */
  IP_Status_BarrierOptimal = 70,
 /* stage status: optimal solution found of penalty problem. */
  IP_Status_PenaltyOptimal = 80,
 /* stage status: search direction is zero. */
  IP_Status_SearchDirectionZero = 90,
 /* stage status: too big. */
  IP_Status_TooBig = 100,
 /* stage status: primal iterates diverge. */
  IP_Status_Diverging = 110,
 /* stage status: NaN evaluation. */
  IP_Status_NaN = 120,
 /* stage status: kkt matrix not positive definite. */
  IP_Status_NotPosDef = 130,
 /* stage status: kkt matrix singular. */
  IP_Status_Singular = 140,
 /* WORHP IP: Penalty type classic interior-point */
  IP_PenaltyType_No = 1,
 /* WORHP IP: Penalty type l1-penalty-interior-point */
  IP_PenaltyType_L1 = 2,
 /* WORHP IP: Penalty type l2-penalty-interior-point */
  IP_PenaltyType_L2 = 3,
 /* WORHP IP: Penalty type augmented Lagrangian penalty-interior-point */
  IP_PenaltyType_AugLagr = 4,
 /* WORHP IP: linear equation system for classic interior-point */
  IP_Leq_Std = 1,
 /* WORHP IP: linear equation system for l1-penalty-interior-point */
  IP_Leq_PenL1 = 2,
 /* WORHP IP: linear equation system for l2-penalty-interior-point */
  IP_Leq_PenL2 = 3,
 /* WORHP IP: linear equation system for augmented lagrangian interior-point */
  IP_Leq_PenAugLagr = 4,
 /* WORHP IP: linear equation system for multiplier estimation */
  IP_Leq_Est = 5,
 /* method: none, line search disabled */
  Line_Method_None = 1,
 /* method: filter. */
  Line_Method_Filter = 2,
 /* method: merit function. */
  Line_Method_Merit = 3,
 /* method: filter/merit function. */
  Line_Method_FilterMerit = 4,
 /* stages status: everything is fine, continue. */
  Line_Status_OK = 100,
 /* stages status: full step size is acceptable. */
  Line_Status_AcceptedFullStep = 200,
 /* stages status: step size is acceptable. */
  Line_Status_Accepted = 300,
 /* stages status: step size is not acceptable. */
  Line_Status_NotAccepted = 400,
 /* stages status: full step size is not acceptable. */
  Line_Status_NotAcceptedFullStep = 500,
 /* stages status: NaN evaluation. */
  Line_Status_NaN = 600,
 /* stages status: minimum step size reached. */
  Line_Status_MinimumStepsize = 700,
 /* stages status: line search was aborted. */
  Line_Status_Aborted = 800,
 /* stages status: otherwise. */
  Line_Status_Else = 900,
 /*-----------------------------------------------------------------
  *  Array sizes
  *-----------------------------------------------------------------*/
  WMTslices = 100,
  WMTrows = 6,
  WMTnames = 20,
  NAres = 7,
  NUserAction = 14,
  NStageHistory = 10,
 /*-----------------------------------------------------------------
  *  Feasibility mode flags
  *-----------------------------------------------------------------*/
  FEAS_MODE_OFF = 0,
  FEAS_MODE_INITIAL = 1,
 /* was: JustFeasible */
  FEAS_MODE_NOOBJ = 2,
 /* was: FeasModeActive */
  FEAS_MODE_DUAL = 4,
 /*-----------------------------------------------------------------
  *  NLP algorithm flag
  *-----------------------------------------------------------------*/
  ALGORITHM_SQP = 1,
  ALGORITHM_IP = 2,
 /*-----------------------------------------------------------------
  *  Zen RC flags
  *-----------------------------------------------------------------*/
  Zen_RC_Init = 0,
  Zen_RC_Renew_LU = 1,
  Zen_RC_DGp = 2,
  Zen_RC_DLp = 3,
  Zen_RC_DLxp = 4,
  Zen_RC_DLpp = 5,
 /*-----------------------------------------------------------------
  *  User action constants
  *-----------------------------------------------------------------*/
  callWorhp = 1,
  evalF = 2,
  evalG = 3,
  evalDF = 4,
  evalDG = 5,
  evalHM = 6,
  evalZenDGp = 7,
  evalZenDLxp = 8,
  evalZenDLp = 9,
  evalZenDLpp = 10,
  iterOutput = 11,
  fidif_DF = 12,
  fidif_DG = 13,
  fidif_HM = 14,
 /* Not actually a user action, but a combination of all fidif_* */
  fidif = 15,
 /*-----------------------------------------------------------------
  *  SQP status constants
  *-----------------------------------------------------------------*/
 /* 1st call to SQP */
  FirstCall = 20,
 /* SQP is iterating */
  Iterating = 21,
 /* SQP is iterating */
  IteratingAres = 22,
 /* 1st Armijo call in current major iter */
  ArmijoFirstCall = 23,
 /* Armijo updates x and flags user action */
  ArmijoUpdate = 24,
 /* Armijo evaluates merit function */
  ArmijoEvaluate = 25,
 /* QP solver wants to try an SLP step */
  SolverSLP = 26,
 /* Setting up Zen */
  ZenSetup = 27,
 /* FD Hessian determination RC flag */
  fidif_HM_RC_start = 200,
 /* FD Hessian determination RC flag */
  fidif_HM_RC_pert_fi = 201,
 /* FD Hessian determination RC flag */
  fidif_HM_RC_pert_fij = 202,
 /* FD Hessian determination RC flag */
  fidif_HM_RC_pert_fdiag = 203,
 /* FD Hessian determination RC flag */
  fidif_HM_RC_pert_gi = 204,
 /* FD Hessian determination RC flag */
  fidif_HM_RC_pert_hgr = 205,
 /* FD Hessian determination RC flag */
  fidif_HM_RC_pert_hgrsgr = 206,
 /* FD Hessian determination RC flag */
  fidif_HM_RC_pert_gij = 207,
 /* FD Hessian determination RC flag */
  fidif_HM_RC_pert_gdiag = 208,
 /* mja: Start status for fidif method without groups */
  fidif_start = 209,
 /* mja: Status for evaluation of the positive side of the difference */
  fidif_posside = 210,
 /* mja: Status for evaluation of the negative side of the difference */
  fidif_negside = 211,
 /* mja: Status for evaluation of f or g in x0 for HM */
  fidif_hm_in_x0 = 212,
 /* mja: Status for evaluation of f or g perturbed in 2 components for HM */
  fidif_hm_2components = 213,
 /* mja: Status for evaluation of positive perturbed df or dg for HM */
  fidif_hm_userdfdg_posside = 214,
 /* mja: Status for evaluation of negative perturbed df or dg for HM */
  fidif_hm_userdfdg_negside = 215,
 /* mja: End status for fidif method without groups */
  fidif_end = 216,
 /*-----------------------------------------------------------------
  *  Armijo recovery strategies
  *-----------------------------------------------------------------*/
 /* Armijo recovery strategy: SLP step */
  AresSLP = 41,
 /* Armijo recovery strategy: Non-monotone */
  AresNonMon = 42,
 /* Armijo recovery strategy: Force 1 */
  AresForce = 43,
 /* Armijo recovery strategy: Switch to dual-feas-mode */
  AresFeas = 44,
 /* Give up */
  AresGiveUp = 50,
 /*-----------------------------------------------------------------
  *  SQP stages
  *-----------------------------------------------------------------*/
  No_Stage = 100,
  Init_Data = 101,
  Pre_KKT = 102,
  Check_KKT = 103,
  Create_QP = 104,
  Hessian_Regularisation = 105,
  Solve_QP = 106,
  Post_QP = 107,
  Find_Stepsize = 108,
  Update_Point = 109,
  Recovery_Strategies = 110,
  Finalise = 111,
  SLP_step = 112,
  Solve_Feasibility_QP = 113,
  Post_Optimum = 114,
  Pre_BStep = 115,
  BStep = 116,
  Post_QP_Sens = 117,
  Worhp_IP_Stage_Modify = 118,
  Worhp_IP_Stage_Unmodify = 119,
  Worhp_IP_Stage_Init = 120,
  Worhp_IP_Stage_InitMode = 121,
  Worhp_IP_Stage_Prepare = 122,
  Worhp_IP_Stage_Check = 123,
  Worhp_IP_Stage_CheckBarrier = 124,
  Worhp_IP_Stage_UpdateBarrier = 125,
  Worhp_IP_Stage_CheckPenalty = 126,
  Worhp_IP_Stage_UpdatePenalty = 127,
  Worhp_IP_Stage_Factorize = 128,
  Worhp_IP_Stage_Regularize = 129,
  Worhp_IP_Stage_Solve = 130,
  Worhp_IP_Stage_LinePrepare = 131,
  Worhp_IP_Stage_LineCheck = 132,
  Worhp_IP_Stage_LineUpdate = 133,
  Worhp_IP_Stage_LineReduce = 134,
 /*-----------------------------------------------------------------
  *  (somehow) successful termination
  *-----------------------------------------------------------------*/
  TerminateSuccess = 1000,
  OptimalSolution = 1001,
 /* IER = 1 */
  SearchDirectionZero = 1002,
 /* IER = 2 */
  SearchDirectionSmall = 1003,
 /* IER = 3 */
  StationaryPointFound = 1004,
  AcceptableSolution = 1005,
  AcceptablePrevious = 1006,
  FritzJohn = 1007,
  NotDiffable = 1008,
  Unbounded = 1009,
  FeasibleSolution = 1010,
  LowPassFilterOptimal = 1011,
  LowPassFilterAcceptable = 1012,
  OptimalSolutionBoxEqual = 1013,
 /* mja: Status that we took this as acceptable solution because we think that F is constant */
  AcceptableSolutionConstantF = 1014,
 /* mja: Status that we took this previous acceptable solution because we think that F is constant */
  AcceptablePreviousConstantF = 1015,
 /* mja: Status that we took this as optimal solution because we think that F is constant */
  OptimalSolutionConstantF = 1016,
 /* mja: Status that we terminate with an optimal solution regarding sKKT, but the user is not happy with that, i.e. parameter sKKTOnlyAcceptable is true */
  AcceptableSolutionSKKT = 1017,
 /*-----------------------------------------------------------------
  *  (somehow) unsuccessful termination
  *-----------------------------------------------------------------*/
  TerminateError = -1000,
  InitError = -1001,
  DataError = -1002,
  MaxCalls = -1003,
 /* IER = 4 */
  MaxIter = -1004,
 /* IER = -3 */
  MinimumStepsize = -1006,
 /* IER < -10 */
  QPerror = -1007,
 /* IER = 6 */
  ProblemInfeasible = -1008,
  GroupsComposition = -1009,
  TooBig = -1010,
  evalsNaN = -1011,
  Timeout = -1012,
  FDError = -1013,
  LocalInfeas = -1014,
  LicenseError = -1015,
  LicenseWarnExpiryDays = 31,
  TerminatedByUser = -1020,
  TerminatedByCheckFD = -1021,
  FunctionErrorF = -1100 - 2,
  FunctionErrorG = -1100 - 3,
  FunctionErrorDF = -1100 - 4,
  FunctionErrorDG = -1100 - 5,
  FunctionErrorHM = -1100 - 6,
  LinearSolverFailed = -1200,
  RegularizationFailed = -1201,
  Diverging = -1202,
  Debug1 = -1203,
  Debug2 = -1204,
  Debug3 = -1205,
  Debug4 = -1206,
  Debug5 = -1207,
  Debug6 = -1208,
  Debug7 = -1209
};


typedef struct OptVarStruct {
  int n;
  int m;
  int k;
  int nGPart;
  int iGPart;
  double F;
  double *X;
  double *XL;
  double *XU;
  double *Lambda;
  double *G;
  double *GL;
  double *GU;
  double *Mu;
  int *GPart;
  double *P;

 /* Indicates that X was changed by WORHP */
  bool newX;

 /* Automatically added initialisation flag.  */
  bool initialised;
} OptVar;

typedef struct WorkspaceStruct {

 /* WORHP IP: optimality of original scaled problem (2-norm) */
  double IP_Opti2;

 /* WORHP IP: optimality of original scaled problem (max norm) */
  double IP_OptiMax;

 /* WORHP IP: feasibility of original scaled problem (2-norm) */
  double IP_Feas2;

 /* WORHP IP: feasibility of original scaled problem (max norm) */
  double IP_FeasMax;

 /* WORHP IP: complementarity of original scaled problem (2-norm) */
  double IP_Compl2;

 /* WORHP IP: complementarity of original scaled problem (max norm) */
  double IP_ComplMax;

 /* WORHP IP: optimality of original unscaled problem (2-norm) */
  double IP_OrigOpti2;

 /* WORHP IP: optimality of original unscaled problem (max norm) */
  double IP_OrigOptiMax;

 /* WORHP IP: feasibility of original unscaled problem (2-norm) */
  double IP_OrigFeas2;

 /* WORHP IP: feasibility of original unscaled problem (max norm) */
  double IP_OrigFeasMax;

 /* WORHP IP: complementarity of original unscaled problem (2-norm) */
  double IP_OrigCompl2;

 /* WORHP IP: complementarity of original unscaled problem (max norm) */
  double IP_OrigComplMax;

 /* WORHP IP: objective of barrier problem */
  double IP_BarrObj;

 /* WORHP IP: objective of barrier/penalty problem */
  double IP_BarrPenObj;

 /* WORHP IP: feasibility of barrier/penalty problem (2-norm) */
  double IP_BarrPenFeas2;

 /* WORHP IP: feasibility of barrier/penalty problem (max norm) */
  double IP_BarrPenFeasMax;

 /* WORHP IP: complementarity of barrier problem (2-norm) */
  double IP_BarrCompl2;

 /* WORHP IP: complementarity of barrier problem (max norm) */
  double IP_BarrComplMax;

 /* WORHP IP: barrier parameter */
  double IP_Barrier;

 /* WORHP IP: min value of barrier parameter */
  double IP_BarrierMin;

 /* WORHP IP: penalty parameter */
  double IP_Penalty;

 /* WORHP IP: penalty parameter (for exact methods) */
  double IP_PenaltyExact;

 /* WORHP IP: fraction-to-the-boundary parameter. */
  double IP_tau;

 /* WORHP IP: iterations after last barrier update */
  int IP_IterUpdate;

 /* WORHP IP: flag for updating barrier parameter */
  bool IP_UpdateBarrier;

 /* WORHP IP: flag for updating penalty parameter */
  bool IP_UpdatePenalty;

 /* WORHP IP: flag for updating exact penalty parameter */
  bool IP_UpdatePenaltyExact;
  size_t dim_IP_HistoryBarrPenKKT;
  size_t dim_IP_HistoryBarrFeas;

 /* WORHP IP: old KKT conditions of barrier / penalty problem of iterations in which it has been optimal */
  double *IP_HistoryBarrPenKKT;

 /* WORHP IP: old feasibility of barrier problem of iterations in which penalty problem has been optimal */
  double *IP_HistoryBarrFeas;

 /* WORHP IP: regularization term in hessian */
  double IP_RegTau;

 /* WORHP IP: regularization term in jacobian */
  double IP_RegTauC;

 /* WORHP IP: former regularization term in hessian */
  double IP_RegTauOld;

 /* WORHP IP: scaling factor for optimality in KKT conditions */
  double IP_ScaleKKTOpt;

 /* WORHP IP: scaling factor for feasibility in KKT conditions */
  double IP_ScaleKKTFeas;

 /* WORHP IP: scaling factor of objective */
  double IP_ScaleF;
  size_t dim_IP_ScaleX;
  size_t dim_IP_ScaleG;

 /* WORHP IP: scaling factor of optimization variable */
  double *IP_ScaleX;

 /* WORHP IP: scaling factor of constraints */
  double *IP_ScaleG;
  size_t dim_IP_XL0;
  size_t dim_IP_XU0;
  size_t dim_IP_GL0;
  size_t dim_IP_GU0;

 /* WORHP IP: original lower bound of X */
  double *IP_XL0;

 /* WORHP IP: original upper bound of X */
  double *IP_XU0;

 /* WORHP IP: original lower bound of G */
  double *IP_GL0;

 /* WORHP IP: original upper bound of G */
  double *IP_GU0;
  size_t dim_IP_S;
  size_t dim_IP_LambdaXL;
  size_t dim_IP_LambdaXU;
  size_t dim_IP_LambdaSL;
  size_t dim_IP_LambdaSU;
  size_t dim_IP_X0;
  size_t dim_IP_Mu0;
  size_t dim_IP_S0;
  size_t dim_IP_LambdaXL0;
  size_t dim_IP_LambdaXU0;
  size_t dim_IP_LambdaSL0;
  size_t dim_IP_LambdaSU0;

 /* WORHP IP: slack variables */
  double *IP_S;

 /* WORHP IP: lagrange multiplier of lower bound of X */
  double *IP_LambdaXL;

 /* WORHP IP: lagrange multiplier of upper bound of X */
  double *IP_LambdaXU;

 /* WORHP IP: lagrange multiplier of lower bound of slacks */
  double *IP_LambdaSL;

 /* WORHP IP: lagrange multiplier of upper bound of slacks */
  double *IP_LambdaSU;

 /* WORHP IP: optimization variable before linesearch */
  double *IP_X0;

 /* WORHP IP: lagrange multiplier Mu before linesearch */
  double *IP_Mu0;

 /* WORHP IP: slack variables before linesearch */
  double *IP_S0;

 /* WORHP IP: IP_LambdaXL before linesearch */
  double *IP_LambdaXL0;

 /* WORHP IP: IP_LambdaXU before linesearch */
  double *IP_LambdaXU0;

 /* WORHP IP: IP_LambdaSL before linesearch */
  double *IP_LambdaSL0;

 /* WORHP IP: IP_LambdaSU before linesearch */
  double *IP_LambdaSU0;

 /* WORHP IP: system matrix for the linear equation system */
  WorhpMatrix IP_LEQ;
  size_t dim_IP_LeqX;

 /* WORHP IP: right-hand-side and solution of linear equation system. */
  double *IP_LeqX;

 /* WORHP IP: start index of block 11 */
  int IP_Leq11s;

 /* WORHP IP: end index of block 11 */
  int IP_Leq11e;

 /* WORHP IP: start index of block 21 */
  int IP_Leq21s;

 /* WORHP IP: end index of block 21 */
  int IP_Leq21e;

 /* WORHP IP: start index of block 31 */
  int IP_Leq31s;

 /* WORHP IP: end index of block 31 */
  int IP_Leq31e;

 /* WORHP IP: start index of block 22 */
  int IP_Leq22s;

 /* WORHP IP: end index of block 22 */
  int IP_Leq22e;

 /* WORHP IP: start index of block 23 */
  int IP_Leq23s;

 /* WORHP IP: end index of block 23 */
  int IP_Leq23e;

 /* WORHP IP: start index of block 33 */
  int IP_Leq33s;

 /* WORHP IP: end index of block 33 */
  int IP_Leq33e;

 /* WORHP IP: start index of block 44 */
  int IP_Leq44s;

 /* WORHP IP: end index of block 44 */
  int IP_Leq44e;

 /* WORHP IP: indicates inertia status of the LEQ matrix. */
  int IP_Inertia;

 /* WORHP IP: residual ratio of iterative refinement */
  double IP_ItRefRatio;

 /* WORHP IP: iteration counter for iterative refinement */
  int IP_ItRefIter;

 /* WORHP IP: indicates if quality has been increased in this iteration */
  bool IP_LeqIncQuality;
  size_t dim_IP_DX;
  size_t dim_IP_DS;
  size_t dim_IP_DMu;
  size_t dim_IP_DLambdaXL;
  size_t dim_IP_DLambdaXU;
  size_t dim_IP_DLambdaSL;
  size_t dim_IP_DLambdaSU;
  size_t dim_IP_DX0;
  size_t dim_IP_DS0;
  size_t dim_IP_DMu0;
  size_t dim_IP_DLambdaXL0;
  size_t dim_IP_DLambdaXU0;
  size_t dim_IP_DLambdaSL0;
  size_t dim_IP_DLambdaSU0;

 /* WORHP IP: search direction of X */
  double *IP_DX;

 /* WORHP IP: search direction of S */
  double *IP_DS;

 /* WORHP IP: search direction of Mu */
  double *IP_DMu;

 /* WORHP IP: search direction of LambdaXL */
  double *IP_DLambdaXL;

 /* WORHP IP: search direction of LambdaXU */
  double *IP_DLambdaXU;

 /* WORHP IP: search direction of LambdaSL */
  double *IP_DLambdaSL;

 /* WORHP IP: search direction of LambdaSU */
  double *IP_DLambdaSU;

 /* WORHP IP: search direction of X without corrections */
  double *IP_DX0;

 /* WORHP IP: search direction of S without corrections */
  double *IP_DS0;

 /* WORHP IP: search direction of Mu without corrections */
  double *IP_DMu0;

 /* WORHP IP: search direction of LambdaXL without corrections */
  double *IP_DLambdaXL0;

 /* WORHP IP: search direction of LambdaXU without corrections */
  double *IP_DLambdaXU0;

 /* WORHP IP: search direction of LambdaSL without corrections */
  double *IP_DLambdaSL0;

 /* WORHP IP: search direction of LambdaSU without corrections */
  double *IP_DLambdaSU0;
  size_t dim_IP_RhsX;
  size_t dim_IP_RhsS;
  size_t dim_IP_RhsMu;
  size_t dim_IP_RhsLambdaXL;
  size_t dim_IP_RhsLambdaXU;
  size_t dim_IP_RhsLambdaSL;
  size_t dim_IP_RhsLambdaSU;

 /* WORHP IP: right-hand-side of X, S and Mu */
  double *IP_RhsX;

 /* WORHP IP: right-hand-side of X, S and Mu */
  double *IP_RhsS;

 /* WORHP IP: right-hand-side of X, S and Mu */
  double *IP_RhsMu;

 /* WORHP IP: right-hand-side of LambdaXL */
  double *IP_RhsLambdaXL;

 /* WORHP IP: right-hand-side of LambdaXU */
  double *IP_RhsLambdaXU;

 /* WORHP IP: right-hand-side of LambdaSL */
  double *IP_RhsLambdaSL;

 /* WORHP IP: right-hand-side of LambdaSU */
  double *IP_RhsLambdaSU;
  size_t dim_IP_ResX;
  size_t dim_IP_ResS;
  size_t dim_IP_ResMu;
  size_t dim_IP_ResLambdaXL;
  size_t dim_IP_ResLambdaXU;
  size_t dim_IP_ResLambdaSL;
  size_t dim_IP_ResLambdaSU;

 /* WORHP IP: residual of X */
  double *IP_ResX;

 /* WORHP IP: residual of S */
  double *IP_ResS;

 /* WORHP IP: residual of Mu */
  double *IP_ResMu;

 /* WORHP IP: residual of LambdaXL */
  double *IP_ResLambdaXL;

 /* WORHP IP: residual of LambdaXU */
  double *IP_ResLambdaXU;

 /* WORHP IP: residual of LambdaSL */
  double *IP_ResLambdaSL;

 /* WORHP IP: residual of LambdaSU */
  double *IP_ResLambdaSU;
  size_t dim_IP_DL;

 /* WORHP IP: gradient of lagrangian */
  double *IP_DL;
  size_t dim_IP_AugMu;
  size_t dim_IP_AugLambdaXL;
  size_t dim_IP_AugLambdaXU;
  size_t dim_IP_AugLambdaSL;
  size_t dim_IP_AugLambdaSU;

 /* WORHP IP: augmented lagrangian parameter for mu */
  double *IP_AugMu;

 /* WORHP IP: augmented lagrangian parameter for LambdaXL */
  double *IP_AugLambdaXL;

 /* WORHP IP: augmented lagrangian parameter for LambdaXU */
  double *IP_AugLambdaXU;

 /* WORHP IP: augmented lagrangian parameter for LambdaSL */
  double *IP_AugLambdaSL;

 /* WORHP IP: augmented lagrangian parameter for LambdaSU */
  double *IP_AugLambdaSU;

 /* WORHP IP: flag for evaluation of optimality */
  bool IP_EvalOpti;

 /* WORHP IP: flag for evaluation of feasibility */
  bool IP_EvalFeas;

 /* WORHP IP: flag for evaluation of complementarity */
  bool IP_EvalCompl;

 /* WORHP IP: flag for evaluation of original optimality */
  bool IP_EvalOrigOpti;

 /* WORHP IP: flag for evaluation of original feasibility */
  bool IP_EvalOrigFeas;

 /* WORHP IP: flag for evaluation of original complementarity */
  bool IP_EvalOrigCompl;

 /* WORHP IP: flag for evaluation of barrier objective */
  bool IP_EvalBarrObj;

 /* WORHP IP: flag for evaluation of l1-penalty objective */
  bool IP_EvalBarrPenL1Obj;

 /* WORHP IP: flag for evaluation of l2-penalty objective */
  bool IP_EvalBarrPenL2Obj;

 /* WORHP IP: flag for evaluation of augmented lagrangian objective */
  bool IP_EvalBarrPenAugLagrObj;

 /* WORHP IP: flag for evaluation of barrier/penalty feasibility */
  bool IP_EvalBarrPenFeas;

 /* WORHP IP: flag for evaluation of barrier complementarity */
  bool IP_EvalBarrCompl;

 /* WORHP_IP: indicates if gradient of lagrangian needs to be evaluated */
  bool IP_EvalGradLagr;

 /* WORHP IP: flag for evaluation of barrier descent */
  bool IP_EvalBarrDescent;

 /* WORHP IP: flag for evaluation of l1-penalty descent */
  bool IP_EvalBarrPenL1Descent;

 /* WORHP IP: flag for evaluation of l2-penalty descent */
  bool IP_EvalBarrPenL2Descent;

 /* WORHP IP: flag for evaluation of augmented Lagrangian penalty descent */
  bool IP_EvalBarrPenAugLagrDescent;

 /* WORHP IP: flag for evaluation of stable descent */
  bool IP_EvalDescentStable;

 /* WORHP IP: tolerance for the barrier subproblem. */
  double IP_TolBarr;

 /* WORHP IP: tolerance for the barrier / penalty subproblem. */
  double IP_TolBarrPen;

 /* WORHP IP: lowpass filter for objective of barrier problem */
  double IP_LowpassBarrObj;

 /* WORHP IP: lowpass filter for complementarity of barrier problem */
  double IP_LowpassBarrCompl;

 /* WORHP IP: lowpass filter for objective of barrier /penalty problem */
  double IP_LowpassBarrPenObj;

 /* WORHP IP: lowpass filter for feasibility of barrier /penalty problem */
  double IP_LowpassBarrPenFeas;

 /* WORHP IP: mode of interior-point method. */
  int IP_Mode;

 /* WORHP IP: status after evaluation of IP stage. */
  int IP_StageStatus;

 /* WORHP Line: current primal stepsize */
  double Line_AlphaX;

 /* WORHP Line: primal stepsize before second-order-correction */
  double Line_Alpha0X;

 /* WORHP Line: primal step size of last iteration */
  double Line_AlphaOldX;

 /* WORHP Line: maximum primal stepsize */
  double Line_AlphaMaxX;

 /* WORHP Line: current lambda stepsize */
  double Line_AlphaLambda;

 /* WORHP Line: lambda stepsize before second-order-correction */
  double Line_Alpha0Lambda;

 /* WORHP Line: lambda step size of last iteration */
  double Line_AlphaOldLambda;

 /* WORHP Line: maximum lambda stepsize */
  double Line_AlphaMaxLambda;

 /* WORHP Line: current mu stepsize */
  double Line_AlphaMu;

 /* WORHP Line: mu stepsize before second-order-correction */
  double Line_Alpha0Mu;

 /* WORHP Line: mu step size of last iteration */
  double Line_AlphaOldMu;

 /* WORHP Line: maximum mu stepsize */
  double Line_AlphaMaxMu;

 /* WORHP Line: minimal step size */
  double Line_AlphaMin;

 /* WORHP Line: CV threshold for switching condition */
  double Line_FilterCVmin;

 /* WORHP Line: filter criteria objective */
  double Line_FilterObj;

 /* WORHP Line: filter criteria feasibility */
  double Line_FilterFeas;

 /* WORHP Line: filter criteria objective without step */
  double Line_FilterObj0;

 /* WORHP Line: filter criteria feasibility without step */
  double Line_FilterFeas0;

 /* WORHP Line: merit function value. */
  double Line_Merit;

 /* WORHP Line: merit function value without step. */
  double Line_Merit0;

 /* WORHP Line: merit function of last step. */
  double Line_MeritOld;

 /* WORHP LINE: iteration counter of line search */
  counter Line_Iter;

 /* WORHP LINE: iteration counter of second order corrections */
  counter Line_IterCorrect;

 /* WORHP LINE: status after evaluation of Line stage. */
  int Line_Status;

 /* WORHP LINE: selects method (filter, merit function...) */
  int Line_Method;

 /* WORHP LINE: enables step size interpolation. */
  bool Line_Interp;

 /* WORHP LINE: min decrease in relation to old step size */
  double Line_InterpMin;

 /* WORHP LINE: max decrease in relation to old step size */
  double Line_InterpMax;

 /* WORHP LINE: armijo beta for step size reduction. */
  double Line_ArmijoBeta;

 /* WORHP LINE: filter objective decrease factor */
  double Line_FilterGammaObj;

 /* WORHP LINE: filter constraint violation decrease factor */
  double Line_FilterGammaFeas;

 /*------------------------------------------------
  *  Filter nodes
  *------------------------------------------------ */
  FilterNode *FirstFilterNode;

 /*------------------------------------------------
  *  QP Workspace
  *------------------------------------------------ */
  QPWorkspace qp;

 /* Debug marker. Used to find memory alignment/padding issues */
  int DebugMarker01;

 /*------------------------------------------------
  *  Matrices
  *------------------------------------------------ */
  WorhpMatrix DF;
  WorhpMatrix DG;
  WorhpMatrix DL;
  WorhpMatrix oldDL;
  WorhpMatrix HM;
  WorhpMatrix ID;
  WorhpMatrix Q;
  WorhpMatrix A;
  WorhpMatrix C;

 /* Incidence matrix for group algorithms */
  WorhpMatrix Inc;

 /* RHS for calculation of sensitivity for correction step. */
  WorhpMatrix Bstep_RHS;

 /* Sensitivity derivative for correction step dmu/dq. */
  WorhpMatrix Bstep_dmudq;

 /* Perturbation for sensitivity analysis in correction step. */
  WorhpMatrix BstepPerturbG;

 /* Search direction in correction step. */
  WorhpMatrix BstepDx;

 /* Search direction for lagrangian multipliers in correction step. */
  WorhpMatrix BstepDMu;

 /* Saves final lagrange multiplier for lower box constraints. */
  WorhpMatrix BstepInitialZL;

 /* Saves final lagrange multiplier for upper box constraints. */
  WorhpMatrix BstepInitialZU;

 /* Saves the last 2 iterates of the primal variables to perform a Steffensen Extrapolation step. */
  WorhpMatrix BstepSteffensenOldIterates;

 /* Saves the last 2 iterates of the dual variables (box constraints) to perform a Steffensen Extrapolation step. */
  WorhpMatrix BstepSteffensenOldLambdas;

 /* Saves the last 2 iterates of the dual variables (general constraints) to perform a Steffensen Extrapolation step. */
  WorhpMatrix BstepSteffensenOldMus;

 /* Derivative DG_P for post analysis */
  WorhpMatrix ZenDGp;

 /* Derivative DL_XP (Lagrangian) for post analysis */
  WorhpMatrix ZenDLxp;

 /* Derivative DL_P (Lagrangian) for post analysis */
  WorhpMatrix ZenDLp;

 /* Derivative DL_PP (Lagrangian) for post analysis */
  WorhpMatrix ZenDLpp;

 /* Sensitivity derivatives dx/dp, d^2f/(dr*dq). */
  WorhpMatrix ZenDx_pDf2_rp;

 /* Sensitivity derivatives dx/dr, d^2f/dr^2. Symmetric. */
  WorhpMatrix ZenDx_rDf2_rr;

 /* Sensitivity derivative dx/dq, (dmu/dr)^T, d^2f/(dr*dq). */
  WorhpMatrix ZenDx_qDm_rDf2_rq;

 /* Sensitivity derivative dmu/dp, d^2f/(dq*dp). */
  WorhpMatrix ZenDm_pDf2_qp;

 /* Sensitivity derivative dmu/dq, df^2/dq^2. Symmetric. */
  WorhpMatrix ZenDm_qDf2_qq;

 /* Sensitivity derivative dlambda/dp, d^2f/(db*dp). */
  WorhpMatrix ZenDl_pDf2_bp;

 /* Sensitivity derivative (dx/db)^T, dlambda/dr, d^2f/(db*dr). */
  WorhpMatrix ZenDl_rDx_bDf2_br;

 /* Sensitivity derivative (dmu/db)^T, dlambda/dq, d^2f/(db*dq). */
  WorhpMatrix ZenDl_qDm_bDf2_bq;

 /* Sensitivity derivative dlambda/db, d^2f/db^2. Symmetric. */
  WorhpMatrix ZenDl_bDf2_bb;

 /* Sensitivity derivative df/dp. Vector. */
  WorhpMatrix ZenDf_p;

 /* Sensitivity derivative d^2f/dp^2. Symmetric. */
  WorhpMatrix ZenDf2_pp;

 /* Sensitivity derivative dg/dp. */
  WorhpMatrix ZenDg_p;

 /* Sensitivity derivative dg/dr. */
  WorhpMatrix ZenDg_r;

 /* Sensitivity derivative dg/dq. */
  WorhpMatrix ZenDg_q;

 /* Sensitivity derivative dg/db. */
  WorhpMatrix ZenDg_b;

 /* FIFO for F values */
  WorhpQueue QueueF;

 /* FIFO for constraint violations */
  WorhpQueue QueueCV;

 /* Debug marker. Used to find memory alignment/padding issues */
  int DebugMarker02;

 /*------------------------------------------------
  *  Reals
  *------------------------------------------------ */

 /* = |dT*H*d|                           [SCAL] */
  double Abs_Curvature;

 /* CV value of best-so-far acceptable solution */
  double AcceptCV;

 /* F value of best-so-far acceptable solution */
  double AcceptF;

 /* KKT value of best-so-far acceptable solution */
  double AcceptKKT;

 /* ScaleObj value of best-so-far acceptable solution */
  double AcceptScaleObj;

 /* Armijo stepsize                      [ALPHA] */
  double ArmijoAlpha;

 /* Betts-update parameter               [ACTUAL] */
  double BettsActual;

 /* Betts-update parameter               [OLDRHO] */
  double BettsOldRho;

 /* Betts-update parameter               [PRDTED] */
  double BettsPredicted;

 /* Used for calculating the Bettsupdate */
  double BettsRho;

 /* Betts-update parameter */
  double BettsSigma;

 /* Sum of Betts-update parameter for AutoQPRecovery */
  double BettsSumTau;

 /* Betts-update parameter               [TAU] */
  double BettsTau;

 /* Betts-update: Value added to HM diag */
  double BettsValue;

 /* Maximum constraint violation at uncorrected next iterate */
  double BstepOldMaxCV;

 /* Value of old Lagrangian function as watch dog for bstep progress */
  double BstepOldLagrangianValue;

 /* = dT*H*d */
  double Curvature;

 /* df^T*d */
  double Descent;

 /* RC value F0 */
  double F0;

 /* 2-Norm of the vector of inactive constraint violations */
  double InActiveNormG;

 /* Lowpass filter value for F */
  double LowPassF;

 /* Lowpass filter value for G */
  double LowPassG;

 /* Lowpass filter value for the merit function */
  double LowPassMerit;

 /* Derivative of merit function         [FAC] */
  double MeritGradient;

 /* New value of merit function        [VAXLK] */
  double MeritNewValue;

 /* Old value of merit function        [VAL] */
  double MeritOldValue;

 /* 2-norm of QP search direction        [NRMDX] */
  double Norm2_DX;

 /* Max-norm of Constraints Violation    [NRMNB] */
  double NormMax_CV;

 /* Max-norm of Gradient of Lagrangian   [NRMGRD] */
  double NormMax_DL;

 /* old value of F */
  double oldF;

 /* old 2-norm of QP search direction */
  double oldNorm2_DX;

 /* old NormMax value of G */
  double oldNormMaxG;

 /* penalty parameter update             [DELTAK] */
  double PenUpdDeltaK;

 /* penalty parameter update             [R] */
  double PenUpdR;

 /* PostQP-Sensitivity, Suggestion for new value */
  double qppsa_HMReg;

 /* New KKT value (sKKT or KKT) */
  double ScaledKKT;

 /* Scaling for the objective function */
  double ScaleObj;

 /* Scaling for the objective function for the QP */
  double ScaleObjQP;

 /* Minimal trial stepsize. */
  double Alpha_Min;

 /* Betts-update parameter. */
  double CVActual;

 /* Derivative of constraint violation. */
  double CVGradient;

 /* Betts-update parameter. */
  double CVPredicted;

 /* Maximal CV for the initialization of the filter. */
  double CV_Max;

 /* If CV < CV_Min check the the switching condition. */
  double CV_Min;

 /* Betts-update parameter. */
  double FActual;

 /* Constraint violation value of the filter entry which dominates the trial iterate. */
  double FilterDominatingCV;

 /* Objective function value of the filter entry which dominates the trial iterate. */
  double FilterDominatingF;

 /* Constraint violation value at the intersection of the filter envelope with the line that connects the previous iterate with the current trial iterate. */
  double FilterIntersectionCV;

 /* Betts-update parameter. */
  double FPredicted;

 /* Original df^T*d for accelerating heuristic (ignore criteria). */
  double olddescent;

 /* Betts-update parameter. */
  double PrevBettsTau;

 /* Initial value of the objective function. */
  double StartF;

 /*------------------------------------------------
  *  Variable size arrays
  *------------------------------------------------ */
  size_t dim_idxXeq;
  size_t dim_idxXneq;
  size_t dim_idxXneqInv;
  size_t dim_idxXieq;
  size_t dim_idxXieqLow;
  size_t dim_idxXieqUp;
  size_t dim_idxGeq;
  size_t dim_idxGieq;
  size_t dim_idxGieqLow;
  size_t dim_idxGieqUp;
  size_t dim_idxDFXneq;
  size_t dim_idxDGXneq;
  size_t dim_idxHMXneq;
  size_t dim_idxHMdiagXneq;
  size_t dim_idxDGGeq;
  size_t dim_idxDGGieq;
  size_t dim_idxDGGieqLow;
  size_t dim_idxDGGieqUp;
  size_t dim_idxDGGieqLowUp;

 /* index map for equality box constraints */
  int *idxXeq;

 /* index map for non-equality box constraints */
  int *idxXneq;

 /* index map like idxXneq but other way round */
  int *idxXneqInv;

 /* index map for inequality box constraints */
  int *idxXieq;

 /* index map for lower inequality box constraints */
  int *idxXieqLow;

 /* index map for upper inequality box constraints */
  int *idxXieqUp;

 /* index map for equality constraints */
  int *idxGeq;

 /* index map for inequality constraints */
  int *idxGieq;

 /* index map for lower inequality constraints */
  int *idxGieqLow;

 /* index map for upper inequality constraints */
  int *idxGieqUp;

 /* index map for DF without Xeq */
  int *idxDFXneq;

 /* index map for DG without Xeq */
  int *idxDGXneq;

 /* index map for HM without Xeq */
  int *idxHMXneq;

 /* index map for diagonal of HM that do not belong to X with equality box constraints */
  int *idxHMdiagXneq;

 /* sge: index map for DG only equality constraints */
  int *idxDGGeq;

 /* sge: index map for DG only inequality constraints */
  int *idxDGGieq;

 /* sge: index map for DG only inequality constraints with lower bound */
  int *idxDGGieqLow;

 /* sge: index map for DG only inequality constraints with upper bound */
  int *idxDGGieqUp;

 /* sge: index map for DG inequality constraints with upper and lower bound */
  int *idxDGGieqLowUp;
  size_t dim_bstepSaveRHS;
  size_t dim_dfdense;
  size_t dim_qpIdxMap;
  size_t dim_qpeqrhs;
  size_t dim_qpierhs;
  size_t dim_qpdx;
  size_t dim_qpdx_reg;
  size_t dim_qpdx_relax;
  size_t dim_qpdx_backup;
  size_t dim_qpeqlm;
  size_t dim_qpeqlm_reg;
  size_t dim_qpeqlm_relax;
  size_t dim_qpeqlm_backup;
  size_t dim_qpielm;
  size_t dim_qpielm_reg;
  size_t dim_qpielm_relax;
  size_t dim_qpielm_backup;
  size_t dim_QPPSA_relaxPen;
  size_t dim_fidif_ddg;
  size_t dim_fidif_DF_CRrow;
  size_t dim_fidif_nPairgroups;
  size_t dim_fidif_Pairgroups;
  size_t dim_fidif_Relentries;
  size_t dim_fidif_Relvars;
  size_t dim_fidif_savex;
  size_t dim_fidif_saveDF;
  size_t dim_fidif_saveDG;
  size_t dim_fidif_saveG0;
  size_t dim_saved_userDF;
  size_t dim_saved_userDG;
  size_t dim_saved_userHM;
  size_t dim_SBFGS_blockval;
  size_t dim_SBFGS_blockcsc;
  size_t dim_SBFGS_blockcol;
  size_t dim_SBFGS_blocksize;
  size_t dim_SBFGS_blockstart;
  size_t dim_SBFGS_inblock;
  size_t dim_SBFGS_idxinblock;

 /* Save bstepRHS before realtime update strategy */
  double *bstepSaveRHS;

 /* values of dense objective gradient for QP */
  double *dfdense;

 /* Mapping from NLP constraints (m) to QP constraints (>= m). Equality constraints are at position nXeq + qpIdxMap(i) within A. Inequality constraints at position qpIdxMap(i) in C. */
  int *qpIdxMap;

 /* RHS of equalities for QP */
  double *qpeqrhs;

 /* RHS of inequalities for QP */
  double *qpierhs;

 /* Search direction from QP */
  double *qpdx;

 /* sge: Search direction from QP enhanced with sensitivities due to hessian regularisation */
  double *qpdx_reg;

 /* sge: Search direction from QP enhanced with sensitivities due to constraint relaxation */
  double *qpdx_relax;

 /* sge: Original search direction before sensitivity enhanced QP */
  double *qpdx_backup;

 /* LMs of equalities from QP */
  double *qpeqlm;

 /* sge: Updated LMs of equalities from QP with post QP PSA for regularisation */
  double *qpeqlm_reg;

 /* sge: Updated LMs of equalities from QP with post QP PSA for relaxation */
  double *qpeqlm_relax;

 /* sge: Backup of LMs of equalities from QP because of post QP PSA */
  double *qpeqlm_backup;

 /* LMs of inequalities from QP */
  double *qpielm;

 /* sge: Updated LMs of inequalities from QP with post QP PSA for regularisation */
  double *qpielm_reg;

 /* sge: Updated LMs of inequalities from QP with post QP PSA for relaxation */
  double *qpielm_relax;

 /* sge: Updated LMs of inequalities from QP because of post QP PSA */
  double *qpielm_backup;

 /* sge: Vector or Scalar value (depending on par.MoreRelax) to update relaxation penalty using PSA. */
  double *QPPSA_relaxPen;

 /* structure of Hessian without f */
  int *fidif_ddg;

 /* mja: Indices of rowstarts in DFval for fast access in fidif */
  int *fidif_DF_CRrow;

 /* vector of number of pairgroups */
  int *fidif_nPairgroups;

 /* vector of pairgroups memberships     [hm%nnz] */
  int *fidif_Pairgroups;

 /* vector of relevant entries for hessiangroup creation [opt%m] */
  int *fidif_Relentries;

 /* vector of relevant variables for hessiangroup creation [opt%n] */
  int *fidif_Relvars;

 /* mja: Vector to save old x to restore after perturbation in fidif */
  double *fidif_savex;

 /* mja: Vector to save DF(x0) for fidif */
  double *fidif_saveDF;

 /* mja: Vector to save DG(x0) for fidif */
  double *fidif_saveDG;

 /* mja: Vector to save G(x0) for fidif */
  double *fidif_saveG0;

 /* mja: Storage for the DF value provided by the user for comparison with DF from fidif */
  double *saved_userDF;

 /* mja: Storage for the DG value provided by the user for comparison with DG from fidif */
  double *saved_userDG;

 /* mja: Storage for the HM value provided by the user for comparison with HM from fidif */
  double *saved_userHM;

 /* values of SBFGS blocks */
  double *SBFGS_blockval;

 /* CS column vector for SBFGS */
  int *SBFGS_blockcsc;

 /* CC column vector for SBFGS */
  int *SBFGS_blockcol;

 /* size of SBFGS blocks */
  int *SBFGS_blocksize;

 /* vector of first columns for SBFGS */
  int *SBFGS_blockstart;

 /* index vector for SBFGS */
  int *SBFGS_inblock;

 /* index vector for SBFGS */
  int *SBFGS_idxinblock;
  size_t dim_NactiveGc;
  size_t dim_NactiveXc;

 /* cumulated number of active constraints */
  int *NactiveGc;

 /* cumulated number of active box constraints */
  int *NactiveXc;
  size_t dim_ZenStatus;
  size_t dim_ZenStatus2;

 /* Calculation status of sensitivity derivatives of x */
  bool *ZenStatusDX;

 /* Calculation status of sensitivity derivatives of mu */
  bool *ZenStatusDM;

 /* Calculation status of sensitivity derivatives of lambda */
  bool *ZenStatusDL;

 /* Calculation status of sensitivity derivatives of f */
  bool *ZenStatusDF;

 /* Calculation status of sensitivity derivatives of f */
  bool *ZenStatusDF2;

 /* Calculation status of sensitivity derivatives of g */
  bool *ZenStatusDG;

 /*------------------------------------------------
  *  Workspace stuff
  *------------------------------------------------ */
  size_t niws;
  size_t nrws;
  int *iws;
  double *rws;
  size_t IWMT[WMTrows][WMTslices];
  size_t RWMT[WMTrows][WMTslices];
  char IWMTnames[WMTnames][WMTslices];
  char RWMTnames[WMTnames][WMTslices];

 /* Debug marker. Used to find memory alignment/padding issues */
  int DebugMarker03;

 /*------------------------------------------------
  *  WMT indices
  *------------------------------------------------ */

 /* Values of LAMBDA of the last acceptable solution */
  rwmt_index acceptlambda;

 /* Values of Mu of the last acceptable solution */
  rwmt_index acceptmu;

 /* Values of X of the last acceptable solution */
  rwmt_index acceptx;

 /* Active Set flags for G */
  iwmt_index activeSetG;

 /* Index of the QP inequality constraints LM in the general problem */
  iwmt_index activeSetGM;

 /* Index of the QP equality constraints LM in the general problem */
  iwmt_index activeSetGMeq;

 /* Index of the QP inequality constraints LM for qp warmstart */
  iwmt_index activeSetGMwarm;

 /* Active Set flags for X */
  iwmt_index activeSetX;

 /* Active Set flags for X */
  iwmt_index activeSetXUpDown;

 /* for realsparse BFGS */
  iwmt_index degree;

 /* Hessian (symmetric) permutation vector */
  iwmt_index hperm;

 /* Hessian inverse (symmetric) permutation vector */
  iwmt_index hperminv;

 /* Inactive Set indicies for G */
  iwmt_index InActiveSetG;

 /* Used for building the box constraints */
  iwmt_index IXLtemp;

 /* Used for building the box constraints */
  iwmt_index IXUtemp;

 /* New Box LMs                          [LQLAM] */
  rwmt_index newlambda;

 /* New Non-box LMs                      [LQLAM] */
  rwmt_index newmu;

 /* Original LAMBDA for Armijo */
  rwmt_index oldlambda;

 /* Original MU for Armijo */
  rwmt_index oldmu;

 /* Original X for Armijo */
  rwmt_index oldx;

 /* Penalty parameters                   [LPEN] */
  rwmt_index penalty;

 /* LMs for penalty parameter update     [LPPADD] */
  rwmt_index penmu;

 /* sge: Counter for feasibility refinement iterations */
  counter RefineFeasIter;

 /* mja: Counter for overall feasibility refinement iterations of all major iterations. */
  counter RefineFeasIterOverall;

 /* constraint relaxation variables      [DELTA] */
  rwmt_index RelaxDelta;

 /* constraint relaxation penaltys       [RDELTA] */
  rwmt_index RelaxPen;

 /* temporary constraint relaxation penaltys */
  rwmt_index RelaxPenTemp;

 /* Vector of scaling factors for the eq. constraints */
  rwmt_index scalecona;

 /* Vector of scaling factors for the ie. constraints */
  rwmt_index scaleconc;

 /* Vector of scaling factors for the eq. constraints */
  rwmt_index scaleconaWAS;

 /* Vector of scaling factors for the ie. constraints */
  rwmt_index scaleconcWAS;

 /* Original G for Armijo */
  rwmt_index oldg;

 /* Original qpdx for accelerating heuristic (ignore criteria). */
  rwmt_index oldqpdx;

 /* WARMSALL for QP warmstart */
  rwmt_index WARMSALL;

 /* WARMSLALL for QP warmstart */
  rwmt_index WARMSLALL;

 /* WARMSUALL for QP warmstart */
  rwmt_index WARMSUALL;

 /* WARMSALL for QP warmstart */
  rwmt_index WARMZALL;

 /* WARMSLALL for QP warmstart */
  rwmt_index WARMZLALL;

 /* WARMSUALL for QP warmstart */
  rwmt_index WARMZUALL;

 /* Used for building the box constraints */
  rwmt_index XLtemp;

 /* Used for building the box constraints */
  rwmt_index XUtemp;

 /*------------------------------------------------
  *  Counters
  *------------------------------------------------ */

 /* MajorIter corresponding to AcceptMerit */
  counter AcceptMajorIter;

 /* Counter: WORHP calls */
  counter Calls;

 /* Iteration counter for force steps */
  counter ForceIter;

 /* Counter for stepping through solver calls */
  counter InteractiveStep;

 /* Last command in interactive mode */
  counter InteractiveLastCmd;

 /* Counter: major (= SQP) iterations */
  counter MajorIter;

 /* Counter: minor (= QP) iterations */
  counter MinorIter;

 /* Counter: overall minor (= QP) iterations of all major iterations. */
  counter MinorIterOverall;

 /* Next Armijo recovery strategy to be used */
  counter NextAres;

 /* Counter for loops with Reverse Communication */
  counter RCCounter;

 /* Counter for loops with Reverse Communication */
  counter RCCounter2;

 /* Counter for loops with Reverse Communication */
  counter RCCounter3;

 /* Counter for loops with Reverse Communication */
  counter RCCounter4;

 /* Counter: Check whether accelerating heuristics would help. */
  counter LScounter;

 /* mja: Counter for current column in HM while using fidif for HM */
  counter fidif_hm_col;

 /* mja: Counter for current HMval index while using fidif for HMval */
  counter fidif_hm_counter;

 /* mja: Counter for current f-part of HMval index while using fidif for HMval */
  counter fidif_hm_counter_f;

 /* mja: Counter for current g-part of HMval index while using fidif for HMval */
  counter fidif_hm_counter_g;

 /* mja: Counter for current DFval index while using fidif for DFval */
  counter fidif_df_counter;

 /* mja: Counter for current DGval index while using fidif for DGval */
  counter fidif_dg_counter;

 /*------------------------------------------------
  *  Dimensions and element counts
  *------------------------------------------------ */
  int blocknnz;
  int boxLDIM;
  int boxUDIM;

 /* Currently active feasibility mode */
  int CurrentFeasMode;

 /* Number of active general constraints */
  int NactiveG;

 /* Number of active NLP constraints */
  int NactiveGNLP;
  int nbcol;
  int nblock;

 /* number of box equality constraints (same naming as index maps) */
  int nXeq;

 /* number of non box equality constraints (same naming as index maps) */
  int nXneq;

 /* number of box inequality constraints (same naming as index maps) */
  int nXieq;

 /* number of box inequality constraints within QP (constraints with lower and upper bound counted twice) */
  int nXieqQP;

 /* number of box inequality constraints with lower bound only (same naming as index maps) */
  int nXieqLow;

 /* number of box inequality constraints with upper bound only (same naming as index maps) */
  int nXieqUp;

 /* number of box inequality constraints with lower and upper bound (same naming as index maps) */
  int nXieqLowUp;

 /* number of general equality constraints (same naming as index maps) */
  int nGeq;

 /* number of general inequality constraints (same naming as index maps) */
  int nGieq;

 /* number of box inequality constraints within QP (constraints with lower and upper bound counted twice) */
  int nGieqQP;

 /* number of general inequality constraints with lower bound only (same naming as index maps) */
  int nGieqLow;

 /* number of general inequality constraints with upper bound only (same naming as index maps) */
  int nGieqUp;

 /* number of general inequality constraints with lower and upper bound (same naming as index maps) */
  int nGieqLowUp;

 /* number of non-zeros of DF that do not belong to X with equality box constraints. */
  int nnzDFXneq;

 /* number of non-zeros of DG that do not belong to X with equality box constraints. */
  int nnzDGXneq;

 /* number of non-zeros of HM that do not belong to X with equality box constraints. */
  int nnzHMXneq;

 /* number of non-zeros of HM diag that do not belong to X with equality box constraints */
  int nnzHMdiagXneq;

 /* number of non-zeros of DG that do belong to general equality constraints. */
  int nnzDGGeq;

 /* number of non-zeros of DG that do belong to general inequality constraints. */
  int nnzDGGieq;

 /* number of non-zeros of DG that do belong to general inequality constraints with only lower bound. */
  int nnzDGGieqLow;

 /* number of non-zeros of DG that do belong to general inequality constraints with only upper bound */
  int nnzDGGieqUp;

 /* number of non-zeros of DG that do belong to general inequality constraints with upper and lower bound */
  int nnzDGGieqLowUp;

 /* Number of variables for QP */
  int nQP;

 /* Stage that is currently being processed in the main 'Worhp' function. Used for proper output in StageMsg. */
  int ProcessedStage;

 /* Number of constraint relaxation variables */
  int RelaxNvar;

 /* Maximum Number of Filter Entries */
  int nFilterEntries;

 /* mja: Number of positive eigenvalues of KKT-matrix in last factorization. */
  int KKTInertiaPosEV;

 /* mjaP: Number of negative eigenvalues of KKT-matrix in last factorization. */
  int KKTInertiaNegEV;

 /* mja: Number of zero eigenvalues of KKT-matrix in last factorization. */
  int KKTInertiaZeroEV;

 /* mja: Iteration in which sKKT were met for functionality of parameter sKKTOnlyAcceptable */
  int TerminationMetSKKTiter;

 /*------------------------------------------------
  *  Logicals
  *------------------------------------------------ */

 /* Current point feasible to acceptable tol.? */
  bool AcceptFeasible;

 /* Current point optimal to acceptable tol.? */
  bool AcceptOptimal;

 /* Found an acceptable solution? */
  bool AcceptSolFound;

 /* mja: Indicates whether the best so far acceptable solution was chosen because F was found to be constant */
  bool AcceptTerminationByConstantF;

 /* Automatic QP Recovery Active? */
  bool AutoQPRecActive;

 /* Do Betts' update */
  bool BettsUpdate;

 /* Complementarity conditions satisfied? */
  bool Complementary;

 /* Problem has constraints on G  <=>  M > 0 */
  bool Constrained;

 /* sge - Flag to signalise BuildBoxConstraints it is called the first time */
  bool BstepFeasFirstTimeBuildBox;

 /* sge - Correction step due to perturbed constraints is active */
  bool BstepFeasActive;

 /* sge - Flag showing that correction via feasibility finished */
  bool BstepFeasFinished;

 /* sge - Correction step was successful */
  bool BstepSuccessful;

 /* sge - Correction step not yet initialised, but first call to armijo */
  bool BstepFirstArmijoCall;

 /* mja: Whether the derivative check is currently happening */
  bool checkingDerivativeValues;

 /* DGslc has been constructed */
  bool DGslcDone;

 /* Current point feasible? */
  bool Feasible;

 /* FeasibleInit shall be used */
  bool FeasibleInit;

 /* FeasibleInit has failed */
  bool FeasibleInitFailed;

 /* FeasibleInit mode has been completed */
  bool FeasibleInitDone;

 /* Focus on feasibility? */
  bool FeasibleStep;

 /* mja: Whether the first evaluation has been done already to help with RC */
  bool fidif_first_evald;

 /* mja: Whether f has been evaluated when using fidif for DF and DG */
  bool fidif_f_evald;

 /* mja: Whether g has been evaluated when using fidif for DF and DG */
  bool fidif_g_evald;

 /* Hessian guaranteed as positive definite */
  bool HMposdef;

 /* HMslc has been constructed */
  bool HMslcDone;

 /* Do estimation for LM? */
  bool InitialLMEst;

 /* sge: Updating the lagrange multipliers requires several informations from the QP. Do not erase those. */
  bool KeepQPVectorsForBstep;

 /* KKT conditions satisfied? */
  bool KKTok;

 /* Whether a major iteration was just finished. Used to update counter of MajorIter correctly. */
  bool MajorIterFinished;

 /* mja: To remember the old par%UserDF value that might be changed for checking the user derivatives */
  bool oldUserDF;

 /* mja: To remember the old par%UserDG value that might be changed for checking the user derivatives */
  bool oldUserDG;

 /* mja: To remember the old par%UserHM value that might be changed for checking the user derivatives */
  bool oldUserHM;

 /* Current point optimal? */
  bool Optimal;

 /* sgef: Post QP Sensitivity analysis used and qpdx altered? */
  bool PostQPSensActive;

 /* Intermediate QP solution used? */
  bool QPNotFinished;

 /* Do constraint relaxation in QP?      [LIQP] */
  bool RelaxCon;

 /* sge: Extraction of regularisation strategy functions required to move a GOTO flag. This boolean is used to perform this move. */
  bool regStrategyGotoFlag;

 /* scaled QP */
  bool scaledQP;

 /* weakactiveset is allowed to set constraint to inactive */
  bool setInactive;

 /* MinimumStepsize hit during TakeQPSol */
  bool TakeQPSolError;

 /* mja: Indicates if the current acceptable or optimal solution was chosen because F was found to be constant */
  bool TerminationByConstantF;

 /* Use identity matrix in QP? */
  bool UseId;

 /* Indicates if the last iteration was in Feasible Mode */
  bool WasFeasMode;

 /* Current point acceptable to filter? */
  bool Acceptable;

 /* AresForce applicable? (don't do it when no search direction is calculated yet) */
  bool AresForce;

 /* Augment filter after accelerating heuristic (ignore criteria)? */
  bool AugmentFilter;

 /* Check full stepsize (accelerating heuristic: ignore criteria)? */
  bool CheckFullStepsize;

 /* Feasibility restoration invoked? */
  bool FeasRest;

 /* Is it the first Hessian regularization? */
  bool FirstHessianReg;

 /* Accept full stepsize in next iteration? */
  bool FullStepsize;

 /* Step size is an f-step-size? */
  bool FStepsize;

 /* PostQP-Sensitivity, alternative qpdx was used and failed */
  bool qppsa_qpdx_failed;

 /* PostQP-Sensitivity, qpdx w.r.t. regularisation available */
  bool qppsa_qpdx_reg_available;

 /* PostQP-Sensitivity, regularisation update available */
  bool qppsa_HMReg_available;

 /* PostQP-Sensitivity, qpdx w.r.t. relaxation available */
  bool qppsa_qpdx_relax_available;

 /* PostQP-Sensitivity, relaxation penalty update available */
  bool qppsa_relaxpen_available;

 /* PostQP-Sensitivity, relaxation penalty sensitivity not negative */
  bool qppsa_relaxpen_failed;

 /* PostQP-Sensitivity, hessian regularisation value newton method failed */
  bool qppsa_HMreg_failed;

 /* Last unsuccessful trial stepsize rejected because of the filter? */
  bool RejectedByFilter;

 /* Is it the second Hessian regularization? */
  bool SecondHessianReg;

 /* SLP step? */
  bool SLPstep;

 /* Accelerating heuristic (ignore criteria) unsuccessful? */
  bool SmallerAlpha;

 /* Switching condition satisfied? */
  bool SwitchingCond;

 /* sge: Use sensitivities with respect to regularisation in post qp psa */
  bool UseRegSens;

 /* sge: Use sensitivities with respect to relaxation in post qp psa */
  bool UseRelaxSens;

 /* Debug marker. Used to find memory alignment/padding issues */
  int DebugMarker04;

 /* Automatically added initialisation flag.  */
  bool initialised;
} Workspace;

typedef struct ParamsStruct {

 /* WORHP IP: Enable the relaxation of bounds */
  bool IP_NlpRelaxBounds;

 /* WORHP IP: Enable the projection back into the original bounds */
  bool IP_NlpStressBounds;

 /* Worhp IP: strategy for updating barrier parameter */
  int IP_BarrierUpdate;

 /* WORHP IP: max iter without update to switch to fast update */
  int IP_BarrierIterFst;

 /* WORHP IP: initial value of barrier parameter */
  double IP_BarrierInit;

 /* WORHP IP: tolerance for barrier parameter */
  double IP_BarrierTol;

 /* WORHP IP: linear decrease factor for barrier. */
  double IP_BarrierLinDecr;

 /* WORHP IP: superlinear decrease power for barrier. */
  double IP_BarrierSupDecr;

 /* WORHP IP: fast linear decrease factor for barrier. */
  double IP_BarrierLinDecrFst;

 /* WORHP IP: fast superlinear decrease power for barrier. */
  double IP_BarrierSupDecrFst;

 /* WORHP IP: max iterations in classic IP algorithm before switch to PIPA. (-1 is infinity, 0 means disabled) */
  int IP_PenaltyZeroIter;

 /* WORHP IP: penalty function (l1, l2, augmented Lagrangian) */
  int IP_PenaltyType;

 /* WORHP IP: strategy for updating penalty parameter */
  int IP_PenaltyUpdate;

 /* WORHP IP: enables the classic interior-point to for beginning */
  bool IP_PenaltyNotFirst;

 /* WORHP IP: initial value of penalty parameter */
  double IP_PenaltyInit;

 /* WORHP IP: tolerance for the penalty problem. */
  double IP_PenaltyTol;

 /* WORHP IP: dual factor for termination criteria */
  double IP_PenaltyTolDual;

 /* WORHP IP: linear increase factor for penalty. */
  double IP_PenaltyLinIncr;

 /* WORHP IP: linear decrease factor for penalty. */
  double IP_PenaltyLinDecr;

 /* WORHP IP: superlinear decrease power for penalty. */
  double IP_PenaltySupDecr;

 /* WORHP IP: value to be considered as divergence of exact penalty */
  double IP_PenaltyExactMax;

 /* WORHP IP: min absolute distance to box bound of X */
  double IP_InitBoundDistAbs;

 /* WORHP IP: min relative distance to box bound of X */
  double IP_InitBoundDistRel;

 /* WORHP IP: min absolute distance to box bound of S */
  double IP_InitBoundDistSAbs;

 /* WORHP IP: min absolute relative to box bound of S */
  double IP_InitBoundDistSRel;

 /* WORHP IP: method for init dual variables */
  int IP_InitMethodDual;

 /* WORHP IP: method for init dual box variables */
  int IP_InitMethodDualBox;

 /* WORHP IP: initial value of box multipliers */
  double IP_InitDualBox;

 /* WORHP IP: enables the check of correct inertia */
  bool IP_RegCheckInertia;

 /* WORHP IP: garantueed min value of descent */
  double IP_RegMinDescent;

 /* WORHP IP: start value for regularization */
  double IP_RegHessStart;

 /* WORHP IP: fraction of old value for regularization */
  double IP_RegHessOldFrac;

 /* WORHP IP: fast increase of value for regularization */
  double IP_RegHessIncrFast;

 /* WORHP IP: normal increase of value for regularization */
  double IP_RegHessIncrStd;

 /* WORHP IP: max value for hessian regularization before considered as failure */
  double IP_RegHessMax;

 /* WORHP IP: jacobian regularization term */
  double IP_RegJac;

 /* WORHP IP: min iterations for iterative refinement */
  int IP_LeqItRefMinIter;

 /* WORHP IP: max iterations for iterative refinement */
  int IP_LeqItRefMaxIter;

 /* WORHP IP: maximum iterations for iterative refinement */
  double IP_LeqItRefTol;

 /* WORHP IP: improvement factor for iterative refinement */
  double IP_LeqItRefImprFac;

 /* WORHP IP: enables further quality improvements for linear system solves */
  bool IP_LeqIncQuality;

 /* WORHP IP: enables the reduced linear system */
  bool IP_LeqReduce;

 /* WORHP IP: line search method (filter, merit function) */
  int IP_LineMethod;

 /* WORHP IP: strategy for choosing primal stepsize */
  int IP_LineAlphaPrimal;

 /* WORHP IP: strategy for choosing first dual stepsize */
  int IP_LineAlphaDual1;

 /* WORHP IP: strategy for choosing second dual stepsize */
  int IP_LineAlphaDual2;

 /* WORHP IP: objective decrease factor in filter */
  double IP_LineFilterGammaObj;

 /* WORHP IP: constraint violation decrease factor in filter */
  double IP_LineFilterGammaFeas;

 /* WORHP IP: update factor for step size */
  double IP_LineArmijoBeta;

 /* WORHP IP: enables interpolation for step size update */
  bool IP_LineInterp;

 /* WORHP IP: min decrease in relation to old step size */
  double IP_LineInterpMin;

 /* WORHP IP: max decrease in relation to old step size */
  double IP_LineInterpMax;

 /* WORHP IP: Enable slack reset after update. */
  bool IP_LineSlackReset;

 /* WORHP IP: minimal fraction to the boundary */
  double IP_LineFracToBound;

 /* WORHP LINE: max iter of second-order correction */
  int IP_LineCorMaxIter;

 /* WORHP IP: max value of primal iterates */
  double IP_CheckMaxPrimal;

 /* WORHP IP: Enable check for NaN / Inf in HM and DG. */
  bool IP_CheckNanInf;

 /* WORHP IP: Enable lowpass filter on barrier level */
  bool IP_CheckLowPassBarr;

 /* WORHP IP: Enable lowpass filter on penalty level */
  bool IP_CheckLowPassPen;

 /* WORHP IP: Enable scaling of objective function. */
  bool IP_ScaleF;

 /* WORHP IP: Enable scaling of constraints. */
  bool IP_ScaleG;

 /* WORHP IP: max gradient after automatic scaling */
  double IP_ScaleMaxGrad;

 /* WORHP IP: min scaling factor of automatic scaling */
  double IP_ScaleMin;

 /* WORHP IP: enable to contiue the optimization if scaled problem is optimal but not unscaled problem. */
  bool IP_ScaleContOpt;

 /* WORHP IP: soc refinement method */
  int IP_SOCRefineMethod;

 /* WORHP IP: max iterations of soc refinement */
  int IP_SOCRefineMaxIter;

 /* WORHP IP: use augmented lagrangian also for inequality box */
  bool IP_Augment;

 /* Pointer to QP parameter structure */
  QPParams qp;

 /* Debug marker. Used to find memory alignment/padding issues */
  int DebugMarker05;

 /*------------------------------------------------
  *  Real parameters
  *------------------------------------------------ */

 /* Tolerance for acceptable feasibility */
  double AcceptTolFeas;

 /* Tolerance for acceptable optimality */
  double AcceptTolOpti;

 /* Trial stepsize decrease factor for Armijo rule */
  double ArmijoBeta;

 /* Trial stepsize decrease factor for Armijo rule when in a recovery strategy */
  double ArmijoBetaAres;

 /* Initial alpha for Armijo rule */
  double ArmijoMaxAlpha;

 /* Lower bound on alpha for Armijo rule */
  double ArmijoMinAlpha;

 /* Lower bound on alpha for Armijo rule during recovery */
  double ArmijoMinAlphaRec;

 /* Scale factor for linearised descent check in Armijo rule */
  double ArmijoSigma;

 /* Update factor for Betts' Hessian regularisation */
  double BettsFactor;

 /* Smallest eigenvalue of the regularised Hessian */
  double BettsPoint;

 /* Factor in determining active constraints by KKT */
  double BoundTolFac;

 /* Upper bound used by Fritz-John heuristic */
  double CheckFJ;

 /* How much the user derivative can differ from fidif without being considered wrong */
  double CheckDerivTol;

 /* Block BFGS curvature condition bound */
  double CurvBCond;

 /* Block BFGS curvature condition regularisation factor */
  double CurvBFac;

 /* BFGS Curvature condition bound */
  double CurvCond;

 /* BFGS curvature condition regularisation factor */
  double CurvFac;

 /* Feasibility tolerance for no-objective feasible mode */
  double FeasibleInitTol;

 /* Finite difference perturbation */
  double FidifEps;

 /* Factor in Focus-on-Feasibility mode */
  double FocusOnFeasFactor;

 /* Upper bound for numbers to be regarded as finite */
  double Infty;

 /* Tolerance for unboundedness detection heuristic */
  double InftyUnbounded;

 /* IP complementarity tolerance in initial multiplier estimate */
  double LMestQPipComTol;

 /* IP residual tolerance in initial multiplier estimate */
  double LMestQPipResTol;

 /* Lowpass-filter update factor for objective values */
  double LowPassAlphaF;

 /* Lowpass-filter update factor for constraint values */
  double LowPassAlphaG;

 /* Lowpass-filter update factor for merit function values */
  double LowPassAlphaMerit;

 /* Any pivot whose modulus is less than this is treated as zero by MA97 */
  double MA97small;

 /* Relative pivot tolerance of MA97 */
  double MA97u;

 /* Max pivot tolerance of MA97 */
  double MA97umax;

 /* Threshold of meritfunction gradient for increasing Hessian regularisation */
  double MeritGradTol;

 /* Penalty update parameter factor for MeritFunction = 4 */
  double PenUpdEpsKFac;

 /* Penalty update parameter factor for MeritFunction = 3 */
  double PenUpdEpsBar;

 /* Max penalty for MeritFunction = 4 */
  double PenUpdMaxDeltaK;

 /* Max factor for increasing penalty for MeritFunction = 4 */
  double PenUpdMaxFac;

 /* Penalty update parameter for MeritFunction = 3 */
  double PenUpdRBar;

 /* (currently unused) Relative precision of objective */
  double PrecisionF;

 /* (currently unused) Relative precision of constraints */
  double PrecisionG;

 /* (currently unused) Scaling factor for QP */
  double QPscaleParam;

 /* Upper bound for accepting the constraint relaxation variable */
  double RelaxMaxDelta;

 /* Upper bound on the constraint relaxation penalty */
  double RelaxMaxPen;

 /* Update factor for the constraint relaxation penalty */
  double RelaxRho;

 /* Initial value of the constraint relaxation penalty */
  double RelaxStart;

 /* Value to scale large objective functions to */
  double ScaleFacObj;

 /* Upper bound on resulting matrix norm for QP scaling */
  double ScaleFacQP;

 /* Initial value for Betts' update dampening term */
  double StartBettsTau;

 /* Timeout in seconds */
  double Timeout;

 /* Complementarity tolerance */
  double TolComp;

 /* Feasibility tolerance */
  double TolFeas;

 /* Optimality tolerance */
  double TolOpti;

 /* (experimental) */
  double TolWeakActive;

 /* Upper bound on constraint violation for too-big heuristic */
  double TooBigCV;

 /* Upper bound on KKT values for too-big heuristic */
  double TooBigKKT;

 /* Machine epsilon */
  double eps;

 /* Increase factor for estimated integer workspace requirement */
  double IncreaseIWS;

 /* Increase factor for estimated real workspace requirement */
  double IncreaseRWS;

 /* Constraint violation decrease factor in Filter acceptance check */
  double FilterGammaCV;

 /* Objective decrease factor in Filter acceptance check */
  double FilterGammaF;

 /* Safety factor for alphamin calculation by Filter */
  double GammaAlpha;

 /* Increase factor for Betts' update dampening term */
  double IncBettsTau;

 /* Larger increase factor for Betts' update dampening term */
  double IncBettsTauMore;

 /* Lower bound for Betts' update dampening term */
  double MinBettsTau;

 /* Goal fraction for the sensitivity based reduction of relaxDelta */
  double PostQPSensRelaxFrac;

 /* Goal fraction for the sensitivity based reduction of the Hessian regularisation */
  double PostQPSensRegValFrac;

 /* Decrease factor for Betts' update dampening term */
  double ReduceBettsTau;

 /* Start tolerance for successful termination of iterative refinement due to perturbation in constraints */
  double RefineStartTol;

 /* Maximum allowed relaxation to apply feasibility refinement */
  double RefineMaxRelax;

 /* Maximum allowed regularisation of the hessian CAUTION absolute value */
  double RefineMaxHMReg;

 /* Filter switching condition parameter */
  double SwitchingDelta;

 /* Filter switching condition parameter */
  double SwitchingSF;

 /* Filter switching condition parameter */
  double SwitchingSCV;

 /*------------------------------------------------
  *  Integer parameters
  *------------------------------------------------ */

 /* Switch between SQP and IP */
  int algorithm;

 /* Armijo recovery strategies */
  int Ares[NAres];

 /* Choose BFGS method (0: dense, 1-3: block, 100+: sparse) */
  int BFGSmethod;

 /* Restart BFGS update after this many iterations */
  int BFGSrestart;

 /* Block size parameter used by certain BFGS methods */
  int BFGSmaxblockSize;

 /* Block size parameter used by certain BFGS methods */
  int BFGSminblockSize;

 /* The number of the iteration in which user derivatives shall be checked */
  int CheckDerivIter;

 /* Select method to determine graph colouring groups */
  int GroupMethod;

 /* Enable XML logfiles and writing interval */
  int LogLevel;

 /* Enable XML result logging and detail level */
  int LogResult;

 /* Ordering used by MA97 */
  int MA97ordering;

 /* Scaling used by MA97 */
  int MA97scaling;

 /* Print level used by MA97 */
  int MA97print;

 /* Node amalgation, controls merging in elimination tree by MA97 */
  int MA97nemin;

 /* Min number of expected flops before parallel execution is used in factorization */
  int MA97factorMin;

 /* Upper bound to Reverse Communication calls */
  int MaxCalls;

 /* Maximum number of Force recovery strategy steps */
  int MaxForce;

 /* (experimental) */
  int MaxGPart;

 /* Upper bound on major iterations */
  int MaxIter;

 /* Select merit function and penalty update [0, 3..5] */
  int MeritFunction;

 /* Select (1) Meritfunction or (3) Filter globalisation */
  int NLPmethod;

 /* NLP print level [-1..4] */
  int NLPprint;

 /* Select method to determine graph colouring pairgroups */
  int PairMethod;

 /* Penalty update parameter */
  int PenUpdEpsKSequence;

 /* 0 - Deactivated, 1 - Use constraint relaxation sensitivity, 2 - Use Hessian regularisation sensitivity, 3 - Use both. */
  int PostQPSensitivity;

 /* 0 - Deactivated, 1 - After first feasible iterate, 2 - Always on, Activates iterative refinement due to perturbation in constraints using parametric sensitivities, 3 - Always on and use realtime update strategy */
  int RefineFeasibility;

 /* sge: Maximum number of feasibility refinement iterations */
  int RefineFeasMaxIter;

 /* Enable automatic Hessian structure generation or checking */
  int UserHMstructure;

 /* Control activation of Filter acceleration heuristics */
  int MaxLScounter;

 /* Select Hessian regularisation strategy in Filter */
  int RegStrategy;

 /*------------------------------------------------
  *  Logical parameters
  *------------------------------------------------ */

 /* Enable automatic QP recovery */
  bool AutoQPRecovery;

 /* Termination criterion for BStep regularisation via lagrangian function */
  bool BStepLagrangeWD;

 /* Enable check of group composition for derivatives */
  bool CheckGroups;

 /* Enable structural checking of DF */
  bool CheckStructureDF;

 /* Enable structural checking of DG */
  bool CheckStructureDG;

 /* Enable structural checking of HM */
  bool CheckStructureHM;

 /* mja: Enable comparison of DF values provided by the user with fidif ones */
  bool CheckValuesDF;

 /* mja: Enable comparison of DG values provided by the user with fidif ones */
  bool CheckValuesDG;

 /* mja: Enable comparison of HM values provided by the user with fidif ones */
  bool CheckValuesHM;

 /* F and G cannot be evaluated separately */
  bool FGtogether;

 /* Enable Fritz-John and non-differentiable check heuristics */
  bool FJandND;

 /* Activate dual feasibility mode */
  bool FeasibleDual;

 /* Activate initial feasibility mode */
  bool FeasibleInit;

 /* Activate feasible-only mode */
  bool FeasibleOnly;

 /* mja: Whether to use group methods for finite differences */
  bool FidifGroups;

 /* Approximate Hessian by finite differences (otherwise BFGS) */
  bool FidifHM;

 /* Use central finite difference quotient for first derivatives */
  bool FirstDifCentral;

 /* Enable Focus-on-Feasibility mode */
  bool FocusOnFeas;

 /* Enable initial Lagrange multiplier estimate */
  bool InitialLMest;

 /* Counter for changed parameters. Internal use only. */
  int internalParChanged;

 /* Save acceptable solutions as fallback */
  bool KeepAcceptableSol;

 /* Control Lagrange multiplier update */
  bool LinMult;

 /* Enable lowpass-filter termination criterion */
  bool LowPassFilter;

 /* Use BLAS level 3 (dgemm) in MA97 */
  bool MA97blas3;

 /* Use multifrontal-style forward solve of MA97 */
  bool MA97mf;

 /* Not to be included into a parameter file! */
  bool MatrixCC;

 /* Introduce one relaxation variable for every constraint */
  bool MoreRelax;

 /* Activate sensitivity based update of relaxation penalty due to PostQPSensRelaxFrac */
  bool PostQPSensRelaxPen;

 /* Activate sensitivity based update of regularisation value using the curvature condition */
  bool PostQPSensRegVal;

 /* If WORHP monitor is available show window. */
  bool ShowMonitor;

 /* Use Steffensen Extrapolation during Feasibility Refinement */
  bool SteffensenOnRefine;

 /* Activates new iterative refinement of constraints only when Armijo alpha equals one */
  bool RefineOnlyOnAlpha;

 /* Only one relaxation penalty if MoreRelax is true */
  bool RelaxPenOnlyOne;

 /* Do restoration until a feasible solution is found */
  bool RestUntilFeas;

 /* Scale constraints in every iteration */
  bool ScaleConIter;

 /* Use a scaled perturbation for finite differences */
  bool ScaledFD;

 /* Scale KKT conditions */
  bool ScaledKKT;

 /* Scale the objective function */
  bool ScaledObj;

 /* Scale some matrices handed to the QP */
  bool ScaledQP;

 /* mja: Use central finite difference quotient for second derivatives */
  bool SecondDifCentral;

 /* mja: If scaled KKT are met, the solution will only be considered acceptable and iteration will continue to try and satisfy normal KKT */
  bool sKKTOnlyAcceptable;

 /* Evaluate QP search direction regardless of convergence */
  bool TakeQPSol;

 /* Enable too-big termination heuristics */
  bool TooBig;

 /* Activates update of lagrange multipliers during correction step */
  bool UpdateMu;

 /* Objective gradient values supplied by caller */
  bool UserDF;

 /* Jacobian values supplied by caller */
  bool UserDG;

 /* Hessian values supplied by caller */
  bool UserHM;

 /* Hessian values supplied by caller */
  bool UserZenDGp;

 /* Hessian values supplied by caller */
  bool UserZenDLxp;

 /* Gradient values supplied by caller */
  bool UserZenDLp;

 /* Hessian values supplied by caller */
  bool UserZenDLpp;

 /* Run Zen module after successful termination */
  bool UseZen;

 /* Check maximum of secure perturbation when updating solution */
  bool ZenCheckMaxPert;

 /* false: use LU from last QP step; true: renew LU decomposition. */
  bool ZenRenewLU;
  bool ZenFDnewMethod;

 /* (experimental) */
  bool WeakActiveSet;

 /* Use a constant lower bound on Armijo stepsize in Filter */
  bool AlphaMinConst;

 /* Activate accelerating heuristics for Filter */
  bool IgnoreFilterCrit;

 /* Filter heuristic to save Armijo iterations */
  bool FilterBisecAlpha;

 /* Filter heuristic to save Armijo iterations */
  bool FilterIntersecAlpha;

 /* Whether to use the feasibility restoration before using any other recovery strategy when the filter is used and the minimum stepsize is reached */
  bool FilterRestFeas;

 /* Select max-norm instead of 1-norm in Filter */
  bool MaxNorm;

 /* Enables Filter-reinitialisation accelerating heuristic */
  bool ReinitFilter;

 /* Debug marker. Used to find memory alignment/padding issues */
  int DebugMarker06;

 /* Automatically added initialisation flag.  */
  bool initialised;
} Params;

typedef struct ControlStruct {
  DateType Date;
  TimerType Timer;

 /* Ring buffer for stage history */
  int Stage[NStageHistory];

 /* Logical field for user action flags */
  bool UserAction[NUserAction];

 /* External status flag */
  int status;

 /* Internal status flag */
  int int_status;

 /* WORHP status cached by Zen */
  int pre_zen_status;
  int currentStage;

 /* Counter for Zen loops with Reverse Communication */
  counter ZenRCcounter1;

 /* Counter for Zen loops with Reverse Communication */
  counter ZenRCcounter2;

 /* True if Zen has been initialised. */
  bool ZenInit;

 /* Automatically added initialisation flag.  */
  bool initialised;
} Control;

/* Defined in Worhp_Data.F90 via C-interop  */
DLL_PUBLIC bool GetUserAction(const Control *cnt, int action);
DLL_PUBLIC void DoneUserAction(Control *cnt, int done);
DLL_PUBLIC void AddUserAction(Control *cnt, int add);
DLL_PUBLIC void SetNextStage(Control*, int);
DLL_PUBLIC int  GetCurrentStage(Control*);
DLL_PUBLIC int  GetPreviousStage(Control*, int);

/* Defined in C_Worhp_Data.c  */
DLL_PUBLIC void WorhpVersion(int *major, int *minor, char (*patch)[PATCH_STRING_LENGTH]);
DLL_PUBLIC int CheckWorhpVersion(int major, int minor, const char *patch);

#ifdef __cplusplus
}
#endif

#endif /* HEADER_C_WORHP_DATA_H_GUARD */


